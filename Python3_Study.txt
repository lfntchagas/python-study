Python3
https://github.com/Pierian-Data/Complete-Python-3-Bootcamp - Notebooks
https://github.com/jmportilla/Complete-Python-Bootcamp - Notebooks python2
pythontutor.com 

https://www.anaconda.com/download/ - 
www.sublimetext.com
- Learn GIT
Version control
https://git-scm.com/
https://guides.github.com/activities/hello-world/ - Create an account.
gitimmersion.com

After Udemy do this course:
https://www.codecademy.com/learn/learn-python#course-landing-page

Full IDE - Spider 
development environment:
Notebook environment: Jupyter notebook 

books:
Learn Python 3 the Hard Way: A Very Simple Introduction to the Terrifyingly Beautiful World of Computers and Code (Zed Shaw's Hard Way Series)


pythontutor.com - show how the conditions are matched.


Python Crash:
https://nostarch.com/pythoncrashcourse2e/
http://ehmatthes.github.io/pcc_2e/


[] - Square brackets

Statement - In programming we call anything that carries out some action a statement.


- PyInstaller
Create a exe from your python script.
pyinstaller myscript.py
will create a exe of your app

-------------------------------------
regexper.com - visualization of pattern 

Regular Expression(Regex)
Is a special sequece of characters that define a search pattern, mainly for use in pattern matching with strings. 

- Shorthand Metacharacters
\w - [a-zA-Z0-9_] word characters
\s - whitespace characters
\d - [0-9] digit characters
\W - [^a-zA-Z0-9_] non-word characters
\S - non-whitespace characters
\D - [^0-9] non-digit characters
. - any character
\n - newline characters
\t - tab characters
\r - carriage-return character

- Wildcards
Wildcards can be used if supported by the cmdlet or command. They are used to represent any character any number of times.
Get-ChildItem*.txt
gci *demos*
Get-Command*et-*net*

[] - Those are used to group a range of acceptable characters.
/ - Delimiters, and indicate that start and the end of the regular expression 

- Basic quantifier characters
? - match 0 or 1 times, 
* - match 0 or more times
+ - match one or more times. 

{} - Means we want to match exactly x(numbers) characteres.
/ - To indicate all 


- Ordinary Characters 
Aa, 0,1,2,3 etc. 

- Control Characters or non-printing characters 
\a
\b - backspace 
\t - Horizontal tab
\n - Line feed
\v - Vertical tab
\f - form feed
\r - carriage return
\e - Escape 

- Meta Characters (Characters with Special Meaning)

- Character Classes []

Positive:
Using character classes is the same to say any of this characters is considered a match.
[abcdef] - sequence of characters
[a-f] - indicate a range of characters
[a-f_%0-9]

Negative:
Match anything except the characters contained in the class. 
[^abcdef] - 
[^a-f] - 
[^a-f_%0-9]

Ex:
[^$0-9]+
Hair colouring	$70

Matching Special characters
[A-Za-z_-] - match -
[--/A-Z]
[A-Z+--]
[A-Za-z^] match ^ as literal
[A-Z\[] - Match [
[A-Z\]] - Match ]

Ex:x
CD5678 #AB1234 

/#[ABCDEF0123456789]/
or
#[A-F0-9]+
/#?([A-F0-9]{6}|[A-F0-9]{3})/

- Pattern Examples:













-------------------------------------


- Assign variables
a = 1
my_number = 100
my_string = 'hello'
my_string2 = "hello"
my_string3 = "I don't do that" # double quote ignore the single quote inside.

Because strings are ordered sequences it means we can using indexing and slicing to grab sub-sections of the string.
Note: White space count as character inside of the string.
 
- Indexing notation uses [] notation after the string (or variable assigned the string). Indexing allows you to grab a single character from the string.
The actions use [] square brackets and a number index to indicate positions of what you wish to grab.
	Character: h  e  l  l  o
	Index:     0  1  2  3  4
Reverse Index: 0 -4 -3 -2 -1  #For example: to get the last string
Ex:
mystring = "Hi ynap"
mystring[5]
out: a 


- Slicing allows you to grab a subsection of multiple characters, a "slice" of the string.
This has the following syntax:
	[start:stop:step]
- start is a numerical index for the slice start
- stop is the index you will go up to (but not include)
- step is the size of the "jump" you take.

mystring = 'abcdefghijk'
mystring[2:]
'cdefghijk'

mystring[:2] # go up to the position 2 but do not include.
'ab'

'abcdefghijk'
mystring[4:7]
'efg'

len('hello') - It's allow you to check the length of the string so I 

print('hello \n\t world')
Special character:
\n - new line
\t - tab

- The order of operations (also called precedence)
1 - Parentheses ()
2 - Multiplication / division
3 - Addition / Subtraction 

- Expression = values + operators 

Expressions are just values combined with operators, and they always evaluate down to a single value. 
The order of operations (also called precedence) of Python math operators is similar to that of mathematics. The ** operator is evaluated first; the *, /, //, and % operators are evaluated next, from left to right; and the + and - operators are evaluated last (also from left to right). You can use parentheses to override the usual precedence if you need to. Enter the following expressions into the interactive shell:
Precedence of operators: *, /, //, %, +, - 

- split method 
by default split by the space.
x = 'Hello World'
x.split()
['Hello', 'World']

create a list data type of the outcome of strings.

-  Data type
Data type is a category for values, and every value belongs to exactly one data type. 
Data type:

Examples
Integers
-2, -1, 0, 1, 2, 3, 4, 5
  
Floating-point numbers
-1.25, -1.0, --0.5, 0.0, 0.5, 1.0, 1.25

Strings
'a', 'aa', 'aaa', 'Hello!', '11 cats'
Python programs can also have text values called strings, or strs (pronounced “stirs”). Always surround your string in single quote (') characters (as in 'Hello' or 'Goodbye cruel world!')
Ex: 
>>> 'Alice' + 'Bob'
'AliceBob'

>>> 'Alice' * 5
'AliceAliceAliceAliceAlice'

>>>type(theBoard['top-R'])
<class 'str'>

- Variables
Variable names are case-sensitive, meaning that spam, SPam, SPAM are different variables. It is a Python convention to start your variable with a lowercase letter.

________Functions():
A function is like a mini-program within a program. A major purpose of functions is to group code that get executed multiple times. Without a function defined, you would have to copy and paste the code each time.

Caveats when use list in a function: 
	Variables do not store list values directly; they store references to lists. This is an important distinction when copying variables or passing lists as arguments in function calls. Because the value that is being copied is the list reference, be aware that any changes you make to the list might impact another variable in your program. You can use copy() or deepcopy() if you want to make changes to a list in one variable without modifying the original list.

In general, you always want to avoid duplicating code, because if you ever decide to update the code—if, for example, you find a bug you need to fix—you’ll have to remember to change the code everywhere you copied it.

- Creating a function:
def hello():
	print('Howdy!')
    print('Howdy!!!')
    print('Hello there.')

hello() # function call 


- function call
is just the function's name followed by parentheses, possibly with some number of arguments in between the parentheses. When the program execution reaches these calls, it will jump to the top line in the function and begin executing the code there. When it reaches the end of the function, the execution returns to the line that called the function and continues moving through the code as before.


- DEF statements with parameters
When you call the print() or len(), you pass in values, called arguments in this context, by typing them between the parentheses. You can also define your own functions that accept arguments. 
Ex:
def hello(name):
	print('Hello' + name)

hello('Alice')
hello('Bob')

	

1 -def hello(name): # name is a parameter.
2    print('Hello' + name)

3 hello('Alice') # Alice is the argument that will be held by the parameter name.
hello('Bob')

#print(name) # if you added print after hello('bob') you would give your a error name because there is no variable named. Parameters forgot the values when the function returns.

The definition of hello() function in this program has a parameter called name. 

1 - A parameter is a variable that an argument is stored in when a function is called. 

In this case, the first time the hello() function is called, it's with the argument 'Alice'
3 - the program execution enters the functions, and the variable name is automatically set to 'Alice', which is what gets printed by the print()statement 2.

Note:
	- One special thing to note about parameters is that the value stored in a parameter is forgotten when the functions returns. For example, if you added print(name)after hello('bob') in the previous program, the program would give you a NameError because there is no variable named.  This variable was destroyed after the function call hello('Bob') had returned, so print(name) would refer to a name variable that does not exist.
	This is similar to how a program's variable are forgotten when the program terminates. 

- Return Values and Return Statements
- Return Value
When you call the len() function and pass it an argument such as 'Hello', the function call evaluates to the integer value 5, which is the length of the string you passed it. In general, the value that a function call evaluates to is called the return value of the function.


Ex:
len(test) # function 
4 # return value of that function len()


- Return Statement 
When creating a function using the def statement, you can specify what the return value should be with a return statement. A return statement consists of the following:
	- The return keyword
	- The value or expression that the function should return
	
When an expression is used with a return statement, the return value is what this expression evaluates to. For example, the following program defines a function that returns a different string depending on what number it is passed as an argument. Type this code into the file editor and save it as magic8Ball.py:
import random
def getAnswer(answerNumber):
    if answerNumber == 1: # the value of r is stored in a parameter named answerNumber.
        return 'It is certain'
    elif answerNumber == 2:
        return 'It is decidedly so'
    elif answerNumber == 3:
        return 'Yes'
    elif answerNumber == 4:
        return 'Reply hazy try again'
    elif answerNumber == 5:
        return 'Ask again later'
    elif answerNumber == 6:
        return 'Concentrate and ask again'
    elif answerNumber == 7:
        return 'My reply is no'
    elif answerNumber == 8:
        return 'Outlook not so good'
    elif answerNumber == 9:
        return 'Very doubtful'
		
r = random.randint(1, 9)
fortune = getAnswer(r)
print(fortune)

#OR print(getAnswer(random.randint(1,9)))

	- r = random.randint(1, 9) # the random.randit function is called and the value is stored in a variable named r.
	- fortune = getAnswer(r) # the getAnswer() function is called with r as the argument. The program execution moves to the top of the the getAnswe() function, and the value r is stored in a parameter named answerNumber. The returned string is assigned to a variable named fortune, which then gets passed to a print() call and is printed to the screen.
	- print(fortune)

# or
#print(getAnswer(random.randint(1, 9))) # Since you can pass return values as an argument to another function call, you could shorten these three lines.

	
- The None Value 
In Python there is a value called None, which represents the absence of a value. None is the only value of the NoneType data type. Just like the Boolean True and False values, None must be typed with a capital N. This value-without-a-value can be helpful when you need to store something that won't be confused for a real value in a variable. One place where none is used is as the return value of print(). The print() function displays text on the escreen, but it doesn't need to return anything in the same way len() or input() does. But since all function calls need to evaluate to a return value, print() returns none. 


	
Examples of functions:

- print()
 - Notice that print() allows you to pass it either integer values or string values. But notice the error that shows up when you type the following into the interactive shell:
>>> print('I am ' + 29 + ' years old.')
Traceback (most recent call last):
  File "<pyshell#6>", line 1, in <module>
    print('I am ' + 29 + ' years old.')
TypeError: Can't convert 'int' object to str implicitly

Python gives an error because you can use the + operator only to add two integers together or concatenate two strings. You can’t add an integer to a string because this is ungrammatical in Python. You can fix this by using a string version of the integer instead.
Correct ex: print('I am ' + str(29) + ' years old.')

- int() 
function is also helpful if you have a number as a string value that you want to use in some mathematics. For example, the input() function always returns a string, even if the user enters a number. Enter spam = input() into the interactive shell and enter 101 when it waits for your text.

- input()
input() function always return a string value.

Ex:
print('What is your name?')
name = input()

>>> spam = input()
101
>>> spam
'101'
The value stored inside spam isn’t the integer 101 but the string '101'. If you want to do math using the value in spam, use the int() function to get the integer form of spam and then store this as the new value in spam.
>>> spam = int(spam)
>>> spam
101


- type()
Check out the type of the variable(int, float, etc)
ex: type(variable_name)
	
	

________Flow Control Statements 
Can decide which python instructions to execute under which conditions. Flow control statement often start with a part called the condition, and all are followed by a block of code called the clause.

- Boolean Values (True or False)
The Boolean data type has only two values: True and False. 

	- Comparison Operators
	Comparison operators compare two values and evaluate down to a single Boolean value. 
	Comparison Operators: 
	== Equal to
	!= Not equal to
	< Less than
	> Greater than
	<= Less than or equal to 
	>= Greater than or equal to
	
	Caveats:
	- The == and != operators can actually work with values of any data type.
	- Note that an integer or floating-point value will always be unequal to a string value.
	- The <, >, <=, and >= operators, on the other hand, work properly only with integer and floating-point values.
	
- Boolean Operators 
The three Boolean operators(and, or, not) are used to compare Boolean values. Like comparison operators, they evaluate these expressions down to a Boolean value(True or False).

	- Not Operator
	Unlike "and" and "or", the not operator operates on only one Boolean value (or expression). The not operator simply evaluates to the opposite Boolean Value.
	not True - False
	not False - True 
	
The Boolean operators have an order of operations just like the math operators do. After any math and comparison operators evaluate, Python evaluates the NOT operators first, then the AND operators, and then the OR operators. 

Python Boolean operator evaluation order( NOT | AND | OR) 
1 - NOT
2 - AND
3 - OR 

Ex of mixing Boolean and Comparison Operators:
>>> 2 + 2 == 4 and not 2 + 2 == 5 and 2 * 2 == 2 + 2
		True		True        True 

result = True

- Elements of Flow Control
Flow control statements often start with a part called the Condition, and all are followed by a block of code called the Clause.

- Conditions (Expression)
Conditions always evaluate down to a Boolean value, True or False. A flow control statement decides what to do based on whether its condition is True or False, and almost every flow control statement uses a condition.
  
- Blocks of Code (Clause)
A block is made up of lines of code that are indented at the same level. You can tell when a block begins and ends from the indentation of the lines of code. There are three rules for blocks.
	1 - blocks begin when the indentation increases. 
	2 - blocks can contain other blocks.
	3 - Blocks end when the indentation decreases to zero or to containing block's indentation.
	4 - New blocks begin only after statement that end with a colon.

The indentation is how Python tell what part is inside the IF statement block and what isn't. A block begins when the indentation increases and ends when the indentation returns to its previous level.
	
	ex:
password ='swordfish'
if password == 'swordfish':
    print('Access granted')
else:
    print('wrong password')
	

- IF Statements
An if statement's clause(that is, the block following the if statement) will execute if the statement's condition is True. The clause is skipped if the condition is False. 
"If this condition is true, execute the code in the clause". 
	An if statement consists of the following:
	- The if keyword
	- A condition(That is, an expression that evaluates to True or False)
	- A colon
	- Starting on the next line, an indented block of code(Called the if clause)
	
	if name == 'Alice':
		print('Hi, Alice.')
		
	- Else Statements
	An if clause can optionally be followed by an else statement. The else clause is executed only when the if statement's condition is False. 
	"If this condition is true, execute this code. Or else, execute that code". An else statement doesn't have a condition, and in code, an else statement always consists of the following:
	- The else keyword
	- A colon
	- Starting on the next line, an indented block of code (called the else clause)
	
	- Elif Statement
	While only one of the if or else clauses will execute, you may have a case where you want one of many possible clauses to execute. The elif statement is an "else if" statement that always follows an if or another elif statement. It provides another condition that is checked only if all of the previous conditions were false. In code, an elif statement always consists of the following:
	- The elif keyword
	- A condition(that is, an expression that evaluates to True or False)
	- A colon
	- Starting on the next line, an indented block of code (called the elif clause)
	
	- When there is a chain of elif statements, only one or none of the clauses will be executed
	
	- Optionally, you can have an else statement after the last elif statement. In that case, it is guaranteed that at least one (and only one) of the clauses will be executed. If the conditions in every if and elif statement are False, then the else clause is executed.
	
	- An Else statement comes at the end. It's block is executed if all of the previous condition have been False.
	
	- The values: 0(Integer), 0.0(float) and ''(empty string) are considered to be Falsely values. When used in conditions they are considered False. You can always see for yourself which values are Truthy of Falsey by passing them to the bool() function.

- While Loop statement
You can make a block of code execute over and over again with a while statement. The code in a while clause will be executed as long as the while statement's condition is True. In code, a while statement always consists of the following:
	- The while keyword
	- A condition(that is, an expression that evaluates to True or False)
	- A colon
	- Starting on the next line, an indented block of code(Called the while clause)
	
spam = 0
while spam < 5:
    print('Hello, world.')
    spam = spam + 1

- Break Statements
There is a shortcut to getting the program execution to break out of a while loop's clause early. If the execution reaches a break statement, it immediately exits the while loop's clause. In code, a break statement simply contains the break keyword.

while True:                         # (1)
    print('Please type your name.')
    name = input()                  # (2)
    if name == 'your name':         # (3)
        break                       # (4)
print('Thank you!')                 # (5)


- Continue statements
Like break statements, continue statements are used inside loops. When the program execution reaches a continue statement, the program execution immediately jumps back to the start of the loop and reevaluates the loop's condition.(This is also what happens when the execution reaches the end of the loop.)

while True:
  print('Who are you?')
  name = input()
  if name != 'Joe':       #(1) If name is different than Joe, then back to the conditional (while)
    continue              #(2) -> Jumps back to the start of the loop and reevaluates the loop's condition.
	
  print('Hello, Joe. What is the password? (It is a fish.)') 
  password = input()      #(3)
  if password == 'swordfish':
    break                 #(4)
print('Access granted.')  #(5)

Notes:
There are some values in other data types that conditions will consider equivalent to True and False. When used in conditions, 0, 0.0, and '' (the empty string) are considered False, while all other values are considered True. For example, look at the following program:

name = '' # empty strings are considered False. 
while name != '': #(1) While this variable is considered empty, "while" will prompt you for a name.
    print('Enter your name:')
    name = input()
print('How many guests will you have?')
numOfGuests = int(input()) 
if numOfGuests != 0: #(2) # if you type 0, the conditional If will consider this condition as False and then will not execute the If statement.
    print('Be sure to have enough room for all your guests.') #(3)
print('Done')

OR

name = '' # empty strings are considered False. 
while not name != '': #(1) While this variable is considered empty, while will prompt you for a name.
    print('Enter your name:')
    name = input()
print('How many guests will you have?')
numOfGuests = int(input()) 
if numOfGuests != 0: #(2) # if you type 0, the conditional If will consider this condition as False and then will not execute the If statement.
    print('Be sure to have enough room for all your guests.') #(3)
print('Done')


- FOR Loop statement:
The while loop keeps looping while its condition is True (which is the reason for its name), but what if you want to execute a block of code only a certain number of times? You can do this with a for loop statement and the range() function.

In code, a for statement looks something like " for i in range(5): " and always includes the following:
	- The for keyword
	- A variable name
	- The in keyword 
	- A call to the range() method with up to three integers passed to it.
	- A colon
	- Starting on the next line, an indented block of code (called the for clause)

print('my name is')
for i in range(5): #The first time it is run, the variable i is set to 0. 
    print('Jimmy five times(' + str(i) + ')');
	
The code in the for loop’s clause is run five times. The first time it is run, the variable i is set to 0. The print() call in the clause will print Jimmy Five Times (0). After Python finishes an iteration through all the code inside the for loop’s clause, the execution goes back to the top of the loop, and the for statement increments i by one. This is why range(5) results in five iterations through the clause, with i being set to 0, then 1, then 2, then 3, and then 4. The variable i will go up to, but will not include, the integer passed to range().
	Note:
	You can use break and continue statements inside for loops as well. The continue statement will continue to the next value of the for loop’s counter, as if the program execution had reached the end of the loop and returned to the start.
	In fact, you can use continue and break statements only inside while and for loops. If you try to use these statements elsewhere, Python will give you an error.
	
The starting, stopping, and stepping arguments to range()
Some functions can be called with multiple arguments separated by a comma, and range() is one of them. This lets you change the integer passed to range() to follow any sequence of integers, including starting at a number other than zero.
for i in range (12, 16)
	print(1)

The first argument will be where the for loop's variable starts, and the second argument will be up to, but no including, the number to stop at.
12
13
14
15

The range() function can also be called with three arguments. The first two arguments will be the start and stop values, and the third will be the step argument. The step is the amount that the variable is increased by after each iteration.
for i in range(0, 10, 2):
    print(i)
	
So calling range(0, 10, 2) will count from zero to eight by intervals of two.
0
2
4
6
8

The range() function is flexible in the sequence of numbers it produces for for loops. For example (I never apologize for my puns), you can even use a negative number for the step argument to make the for loop count down instead of up.
for i in range(5, -1, -1):
    print(i)
Running a for loop to print i with range(5, -1, -1) should print from five down to zero.

5
4
3
2
1
0

- Importing Modules
All Python programs can call a basic set of functions called built-in functions, including the print(), and len() functions. Python also comes with a set of modules called the standard library. Each module is a Python program that contains a related group of functions that can be embedded in your programs. For example, the math module has mathematics-related functions, the random module has random number-related functions, and so on.
Before you can use functions in a module, you must import the module with an Import statement. In code, an import statemetn consists of the following:
	- The import keyword
	- the name of the module
	- Optionally, more module names, as long as they are separated by commas.
	
Once you import a module, you can use all the cool functions of that module. 

Importing different modules:
import random, sys, os, math

import random
for i in range(5):
    print(random.randint(15,20)) 
	
Output:
15
16
16
18
18

#the random.randint() function call evaluates to a random integer value between the two integers that you pass it. Since randint() is in the random module, you must first type random. in front of the function name to tell python to look for this function inside the random module.

	- From import statement 
	An alternative form of the import statement is composed of the "from" keyword, followed by the module name, the import keyword, and a star; for example, 
	from random import *

	with this form of import statement, calls to function in random will not need the random. prefix. However, using the full name makes for more readable code, so it is better to use the normal form of the import statement.
	
- Ending a program Early with sys.exit()
The last flow control concept to cover is how to terminate the program. This always happens if the program execution reaches the bottom of the instructions. However, you can cause the program to terminate, or exit, by calling the sys.exit() function. Since this function is in the sys module, you have to import sys before your program can use it.
Ex:

import sys
while True:
    print('Type exit to exit.')
    response = input()
    if response == 'exit':
        sys.exit()
    print('You typed ' + response + '.')

The only way this program will end is if the user enters exit, causing sys.exit() to be called. 

- Keyword Argumetns and Print()
Most arguments are identified by their position in the function call. For example, random.randint(1, 10) is different from random.randint(10, 1). The function call random.randint(1, 10) will return a random integer between 1 and 10, because the first argument is the low end of the range and the second argument is the high end (while random.randint(10, 1) causes an error).

However, keyword arguments are identified by the keyword put before them in the function call. Keyword arguments are often used for optional parameters. For example, the print() function has the optional parameters "end" and "sep" to specify what should be printed at the end of its arguments and between its arguments (separating them), respectively.

If you ran the following program:

print('Hello')
print('World')
the output would look like this:
Hello
World

The two strings appear on separate lines because the print() function automatically adds a newline character to the end of the string it is passed. However, you can set the end keyword argument to change this to a different string. For example, if the program were this:


print('Hello', end='')
print('World')
the output would look like this:
HelloWorld

The output is printed on a single line because there is no longer a new-line printed after 'Hello'. Instead, the blank string is printed. This is useful if you need to disable the newline that gets added to the end of every print() function call.

Similarly, when you pass multiple string values to print(), the function will automatically separate them with a single space. Enter the following into the interactive shell:
>>> print('cats', 'dogs', 'mice')
cats dogs mice

But you could replace the default separating string by passing the sep keyword argument. Enter the following into the interactive shell:
>>> print('cats', 'dogs', 'mice', sep=',')
cats,dogs,mice

You can add keyword arguments to the functions you write as well, but first you’ll have to learn about the list and dictionary data types in the next two chapters. For now, just know that some functions have optional keyword arguments that can be specified when the function is called.

_______Local and Global Scope
Think of a scope as a container for variables. When a scope is destroyed, all the values stored in the scope’s variables are forgotten. There is only one global scope, and it is created when your program begins.

The reason Python has different scopes instead of just making everything a global variable is so that when variables are modified by the code in a particular call to a function, the function interacts with the rest of the program only through its parameters and the return value. This narrows down the list code lines that may be causing a bug. If your program contained nothing but global variables and had a bug because of a variable being set to a bad value, then it would be hard to track down where this bad value was set. It could have been set from anywhere in the program—and your program could be hundreds or thousands of lines long! But if the bug is because of a local variable with a bad value, you know that only the code in that one function could have set it incorrectly.

- Local Scope
Parameters and variables that are assigned in a called function are said to exist in that function’s local scope. A local scope is created whenever a function is called. Any variables assigned in this function exist within the local scope. When the function returns, the local scope is destroyed, and these variables are forgotten.

- Global Scope
Variables that are assigned outside all functions are said to exist in the global scope.

- Variables
A variable that exists in a local scope is called a local variable, while a variable that exists in the global scope is called a global variable. A variable must be one or the other; it cannot be both local and global. When your program terminates, the global scope is destroyed, and all its variables are forgotten.

Scopes matter for several reasons:
	- Code in the global scope cannot use any local variables.
	- However, a local scope can access global variables.
	- Code in a function’s local scope cannot use variables in any other local scope.
	- You can use the same name for different variables if they are in different scopes. That is, there can be a local variable named spam and a global variable also named spam.


Local Variables Cannot Be Used in the Global Scope
Consider this program, which will cause an error when you run it:


def spam():
    eggs = 31337
spam()
print(eggs)
If you run this program, the output will look like this:


Traceback (most recent call last):
  File "C:/test3784.py", line 4, in <module>
    print(eggs)
NameError: name 'eggs' is not defined
The error happens because the eggs variable exists only in the local scope created when spam() is called. Once the program execution returns from spam, that local scope is destroyed, and there is no longer a variable named eggs. So when your program tries to run print(eggs), Python gives you an error saying that eggs is not defined.

- Local Scopes Cannot Use Variables in Other Local Scopes
A new local scope is created whenever a function is called, including when a function is called from another function. Consider this program:


  def spam():
❶    eggs = 99
❷    bacon()
❸    print(eggs)

  def bacon():
      ham = 101
❹    eggs = 0

❺ spam()
When the program starts, the spam() function is called ❺, and a local scope is created. The local variable eggs ❶ is set to 99. Then the bacon() function is called ❷, and a second local scope is created. Multiple local scopes can exist at the same time. In this new local scope, the local variable ham is set to 101, and a local variable eggs—which is different from the one in spam()’s local scope—is also created ❹ and set to 0.

When bacon() returns, the local scope for that call is destroyed. The program execution continues in the spam() function to print the value of eggs ❸, and since the local scope for the call to spam() still exists here, the eggs variable is set to 99. This is what the program prints.

The upshot is that local variables in one function are completely separate from the local variables in another function.

- Global Variables Can Be Read from a Local Scope
Consider the following program:


def spam():
    print(eggs)
eggs = 42
spam()
print(eggs)
Since there is no parameter named eggs or any code that assigns eggs a value in the spam() function, when eggs is used in spam(), Python considers it a reference to the global variable eggs. This is why 42 is printed when the previous program is run.

- Local and Global Variables with the Same Name
To simplify your life, avoid using local variables that have the same name as a global variable or another local variable. But technically, it’s perfectly legal to do so in Python. To see what happens, type the following code into the file editor and save it as sameName.py:


   def spam():
❶     eggs = 'spam local'
       print(eggs) # prints 'spam local' # local scope 
   def bacon():

❷     eggs = 'bacon local'
       print(eggs) # prints 'bacon local'
       spam()
       print(eggs) # prints 'bacon local'

❸ eggs = 'global'
   bacon()
   print(eggs) # prints 'global'
   
When you run this program, it outputs the following:


bacon local
spam local
bacon local
global

There are actually three different variables in this program, but confusingly they are all named eggs. The variables are as follows:

❶ A variable named eggs that exists in a local scope when spam() is called.

❷ A variable named eggs that exists in a local scope when bacon() is called.

❸ A variable named eggs that exists in the global scope.

Since these three separate variables all have the same name, it can be confusing to keep track of which one is being used at any given time. This is why you should avoid using the same variable name in different scopes.

- The global Statement
If you need to modify a global variable from within a function, use the global statement. If you have a line such as global eggs at the top of a function, it tells Python, “In this function, eggs refers to the global variable, so don’t create a local variable with this name.” For example, type the following code into the file editor and save it as sameName2.py:


  def spam():
❶    global eggs
❷    eggs = 'spam'

  eggs = 'global'
  spam()
  print(eggs)
When you run this program, the final print() call will output this:


spam
Because eggs is declared global at the top of spam() ❶, when eggs is set to 'spam' ❷, this assignment is done to the globally scoped eggs. No local eggs variable is created.

There are four rules to tell whether a variable is in a local scope or global scope:

	- If a variable is being used in the global scope (that is, outside of all functions), then it is always a global variable.

	- If there is a global statement for that variable in a function, it is a global variable.

	- Otherwise, if the variable is used in an assignment statement in the function, it is a local variable.

	- But if the variable is not used in an assignment statement, it is a global variable.
	
Note:
- In a function, a variable will either always be global or always be local. There’s no way that the code in a function can use a local variable named eggs and then later in that same function use the global eggs variable.
	
Note
If you ever want to modify the value stored in a global variable from in a function, you must use a global statement on that variable.

If you try to use a local variable in a function before you assign a value to it, as in the following program, Python will give you an error. To see this, type the following into the file editor and save it as sameName4.py:


  def spam():
      print(eggs) # ERROR!
❶    eggs = 'spam local'

❷ eggs = 'global'
   spam()
If you run the previous program, it produces an error message.


Traceback (most recent call last):
  File "C:/test3784.py", line 6, in <module>
    spam()
  File "C:/test3784.py", line 2, in spam
    print(eggs) # ERROR!
UnboundLocalError: local variable 'eggs' referenced before assignment
This error happens because Python sees that there is an assignment statement for eggs in the spam() function ❶ and therefore considers eggs to be local. But because print(eggs) is executed before eggs is assigned anything, the local variable eggs doesn’t exist. Python will not fall back to using the global eggs variable ❷.	

____Exception Handling
Right now, getting an error, or exception, in your Python program means the entire program will crash.Instead, you want the program to detect errors, handle them, and then continue to run.

Ex:
For example, consider the following program, which has a “divide-by-zero” error. Open a new file editor window and enter the following code, saving it as zeroDivide.py:


def spam(divideBy):
    return 42 / divideBy

print(spam(2))
print(spam(12))
print(spam(0))
print(spam(1))

We’ve defined a function called spam, given it a parameter, and then printed the value of that function with various parameters to see what happens. This is the output you get when you run the previous code:

21.0
3.5
Traceback (most recent call last):
  File "C:/zeroDivide.py", line 6, in <module>
    print(spam(0))
  File "C:/zeroDivide.py", line 2, in spam
    return 42 / divideBy
ZeroDivisionError: division by zero

A ZeroDivisionError happens whenever you try to divide a number by zero. From the line number given in the error message, you know that the return statement in spam() is causing an error.
Errors can be handled with try and except statements. The code that could potentially have an error is put in a try clause. The program execution moves to the start of a following except clause if an error happens.

You can put the previous divide-by-zero code in a try clause and have an except clause contain code to handle what happens when this error occurs.


def spam(divideBy):
    try:
        return 42 / divideBy
    except ZeroDivisionError:
        print('Error: Invalid argument.')

print(spam(2))
print(spam(12))
print(spam(0))
print(spam(1))

Note that any errors that occur in function calls in a try block will also be caught. Consider the following program, which instead has the spam() calls in the try block:


def spam(divideBy):
    return 42 / divideBy

try:
    print(spam(2))
    print(spam(12))
    print(spam(0))
    print(spam(1))
except ZeroDivisionError:
    print('Error: Invalid argument.')
When this program is run, the output looks like this:
21.0
3.5
Error: Invalid argument.

The reason print(spam(1)) is never executed is because once the execution jumps to the code in the except clause, it does not return to the try clause. Instead, it just continues moving down as normal.

________Lists 
Lists and tuples can contain multiple values, which makes it easier to write programs that handle large amounts of data. And since lists themselves can contain other lists, you can use them to arrange data into hierarchical structures.
	- Lists are ordered sequences that can hold a variety of object types
	- The use [] brackets and commas to separate objects in the list. 
	- Lists support indexing and slicing. Lists can be nested and also have a variety of useful methods that can be called off of them.
	- Lists are mutable 
	- Lists are useful data types since they allow you to write code that works on a modifiable number of values in a single variable.
	- Variables do not store list values directly; they store references to lists

	
A list is a value that contains multiple values in an ordered sequence. The term list value refers to the list itself (which is a value that can be stored in a variable or passed to a function like any other value), not the values inside the list value. A list value looks like this: ['cat', 'bat', 'rat', 'elephant']. Just as string values are typed with quote characters to mark where the string begins and ends, a list begins with an opening square bracket and ends with a closing square bracket, []. Values inside the list are also called items. Items are separated with commas (that is, they are comma-delimited). For example, enter the following into the interactive shell:
   >>> [1, 2, 3]
   [1, 2, 3]
   >>> ['cat', 'bat', 'rat', 'elephant']
   ['cat', 'bat', 'rat', 'elephant']
   >>> ['hello', 3.1415, True, None, 42]
   ['hello', 3.1415, True, None, 42]
❶ >>> spam = ['cat', 'bat', 'rat', 'elephant']
   >>> spam
   ['cat', 'bat', 'rat', 'elephant']

The spam variable ❶ is still assigned only one value: the list value. But the list value itself contains other values. The value [] is an empty list that contains no values, similar to '', the empty string.

- Getting Individual Values in a List with Indexes
Say you have the list ['cat', 'bat', 'rat', 'elephant'] stored in a variable named spam. The Python code spam[0] would evaluate to 'cat', and spam[1] would evaluate to 'bat', and so on. The integer inside the square brackets that follows the list is called an index.
	- The first value in the list is at index 0.
	- The second value is at index 1
	- The third value is at index 2, and so on. 

spam = ['cat', 'bat', 'rat', 'elephant']
spam[0] = cat
spam[1] = bat
spam[2] = rat
spam[3] = elephant

For example, type the following expressions into the interactive shell. Start by assigning a list to the variable spam.


   >>> spam = ['cat', 'bat', 'rat', 'elephant']
   >>> spam[0]
   'cat'
   >>> spam[1]
   'bat'
   >>> spam[2]
   'rat'
   >>> spam[3]
   'elephant'
   >>> ['cat', 'bat', 'rat', 'elephant'][3]
   'elephant'

>>> 'The ' + spam[1] + ' ate the ' + spam[0] + '.'
'The bat ate the cat.'

Lists can also contain other list values. The values in these lists of lists can be accessed using multiple indexes, like so:


>>> spam = [['cat', 'bat'], [10, 20, 30, 40, 50]]
>>> spam[0]
['cat', 'bat']
>>> spam[0][1]
'bat'
>>> spam[1][4]
50
The first index dictates which list value to use, and the second indicates the value within the list value. For example, spam[0][1] prints 'bat', the second value in the first list. If you only use one index, the program will print the full list value at that index.

- Negative Indexes
While indexes start at 0 and go up, you can also use negative integers for the index. The integer value -1 refers to the last index in a list, the value -2 refers to the second-to-last index in a list, and so on. Enter the following into the interactive shell:


>>> spam = ['cat', 'bat', 'rat', 'elephant']
>>> spam[-1]
'elephant'
>>> spam[-3]
'bat'
>>> 'The ' + spam[-1] + ' is afraid of the ' + spam[-3] + '.'
'The elephant is afraid of the bat.'

- Getting Sublists with Slices
Just as an index can get a single value from a list, a slice can get several values from a list, in the form of a new list. A slice is typed between square brackets, like an index, but it has two integers separated by a colon. Notice the difference between indexes and slices.

spam[2] is a list with an index (one integer).

spam[1:4] is a list with a slice (two integers).

In a slice, the first integer is the index where the slice starts. The second integer is the index where the slice ends. A slice goes up to, but will not include, the value at the second index. A slice evaluates to a new list value.

>>> spam = ['cat', 'bat', 'rat', 'elephant']
>>> spam[0:4]
['cat', 'bat', 'rat', 'elephant']
>>> spam[1:3]
['bat', 'rat']
>>> spam[0:-1]
['cat', 'bat', 'rat']

As a shortcut, you can leave out one or both of the indexes on either side of the colon in the slice. Leaving out the first index is the same as using 0, or the beginning of the list. Leaving out the second index is the same as using the length of the list, which will slice to the end of the list.

>>> spam = ['cat', 'bat', 'rat', 'elephant']
>>> spam[:2]
['cat', 'bat']
>>> spam[1:]
['bat', 'rat', 'elephant']
>>> spam[:]
['cat', 'bat', 'rat', 'elephant']
>>> spam[2:]
['rat', 'elephant']

- Getting a List's Length with 
The len() function will return the number of values or elements that are in a list value passed to it, just like it can count the number of characters in a string value.
>>> spam = ['cat', 'dog', 'moose']
>>> len(spam)
3

- Copying lists:
my_foods = ['pizza', 'falafel', 'carrot cake']

#friend_foods = my_foods # This syntax actually tells python to associate the new variable friend_foods with the list that is already associated with my_foods, so now both variables point to the same list.

friend_foods = my_foods[:] # <-- Correct way

my_foods.append('cannoli')

print("my favorite foods are:")
friend_foods.append('ice cream')
print(my_foods)


print("\nMy friend's favorite foods are:")
print(friend_foods)


- Changing Values in a List with Indexes
Normally a variable name goes on the left side of an assignment statement, like spam = 42. However, you can also use an index of a list to change the value at that index. For example, spam[1] = 'aardvark' means “Assign the value at index 1 in the list spam to the string 'aardvark'.” Enter the following into the interactive shell:


>>> spam = ['cat', 'bat', 'rat', 'elephant']
>>> spam[1] = 'aardvark'
>>> spam
['cat', 'aardvark', 'rat', 'elephant']
>>> spam[2] = spam[1]
>>> spam
['cat', 'aardvark', 'aardvark', 'elephant']
>>> spam[-1] = 12345
>>> spam
['cat', 'aardvark', 'aardvark', 12345]

- List Concatenation and List Replication
The + operator can combine two lists to create a new list value in the same way it combines two strings into a new string value. The * operator can also be used with a list and an integer value to replicate the list.
>>> [1, 2, 3] + ['A', 'B', 'C']
[1, 2, 3, 'A', 'B', 'C']
>>> ['X', 'Y', 'Z'] * 3
['X', 'Y', 'Z', 'X', 'Y', 'Z', 'X', 'Y', 'Z']

>>> spam = [1, 2, 3]
>>> spam = spam + ['A', 'B', 'C']
>>> spam
[1, 2, 3, 'A', 'B', 'C']

- Removing Values from Lists with Del Statements
The del statement will delete values at an index in a list. All of the values in the list after the deleted value will be moved up one index. For example, enter the following into the interactive shell:

>>> spam = ['cat', 'bat', 'rat', 'elephant']
>>> del spam[2]
>>> spam
['cat', 'bat', 'elephant']
>>> del spam[2]
>>> spam
['cat', 'bat']
The del statement can also be used on a simple variable to delete it, as if it were an “unassignment” statement. If you try to use the variable after deleting it, you will get a NameError error because the variable no longer exists.

In practice, you almost never need to delete simple variables. The del statement is mostly used to delete values from lists.

- list.pop() method 
The pop() method remove the last value of the list and return that value. Also you can pass an index position inside of the method pop(). By default the value between () is -1 that means, the last value of a list.
Ex: 
new_list = ['one', 'two', 'three', 'four']
new_list.pop() # will take off the last value into the list so the new result of the new_list will be: ['one', 'two, 'three']

- list.sort()
Sort the list in place. 
Ex: 
new_list = ['a', 'e', 'c', 'd']
num_list = [4,1,8,3]

- list.reverse()
Will reverse the values in a list.
Ex: 
new_list = ['a', 'e', 'c', 'd']
num_list = [4,1,8,3]


- Using For Loops with List
Technically, a for loop repeats the code block once for each value in a list or list-like value.

for i in range(4):
    print(i)
the output of this program would be as follows:
0
1
2
3

This is because the return value from range(4) is a list-like value that Python considers similar to [0, 1, 2, 3]. The following program has the same output as the previous one:
for i in [0, 1, 2, 3]:
    print(i)
	
What the previous for loop actually does is loop through its clause with the variable i set to a successive value in the [0, 1, 2, 3] list in each iteration

A common Python technique is to use range(len(someList)) with a for loop to iterate over the indexes of a list. For example, enter the following into the interactive shell:

>>> supplies = ['pens', 'staplers', 'flame-throwers', 'binders']
>>> for i in range(len(supplies)):
    print('Index ' + str(i) + ' in supplies is: ' + supplies[i])

Index 0 in supplies is: pens
Index 1 in supplies is: staplers
Index 2 in supplies is: flame-throwers
Index 3 in supplies is: binders

Using range(len(supplies)) in the previously shown for loop is handy because the code in the loop can access the index (as the variable i) and the value at that index (as supplies[i]). Best of all, range(len(supplies)) will iterate through all the indexes of supplies, no matter how many items it contains.

- The IN and NOT IN Operators 
You can determine whether a value is or isn’t in a list with the IN and NOT IN operators. Like other operators, in and not in are used in expressions and connect two values: a value to look for in a list and the list where it may be found. These expressions will evaluate to a Boolean value. 

>>> 'howdy' in ['hello', 'hi', 'howdy', 'heyas']
True
>>> spam = ['hello', 'hi', 'howdy', 'heyas']
>>> 'cat' in spam
False
>>> 'howdy' not in spam
False
>>> 'cat' not in spam
True

- The Multiple Assignment Trick
The multiple assignment trick is a shortcut that lets you assign multiple variables with the values in a list in one line of code. So instead of doing this:

>>> cat = ['fat', 'orange', 'loud']
>>> size = cat[0]
>>> color = cat[1]
>>> disposition = cat[2]
you could type this line of code:

>>> cat = ['fat', 'orange', 'loud']
>>> size, color, disposition = cat

The number of variables and the length of the list must be exactly equal, or Python will give you a ValueError:

>>> cat = ['fat', 'orange', 'loud']
>>> size, color, disposition, name = cat
Traceback (most recent call last):
  File "<pyshell#84>", line 1, in <module>
    size, color, disposition, name = cat
ValueError: need more than 3 values to unpack

The multiple assignment trick can also be used to swap the values in two variables:

>>> a, b = 'Alice', 'Bob'
>>> a, b = b, a
>>> print(a)
'Bob'
>>> print(b)
'Alice'

- Augmented Assignment Operators
When assigning a value to a variable, you will frequently use the variable itself. For example, after assigning 42 to the variable spam, you would increase the value in spam by 1 with the following code:

>>> spam = 42
>>> spam = spam + 1
>>> spam
43
As a shortcut, you can use the augmented assignment operator += to do the same thing:

>>> spam = 42
>>> spam += 1
>>> spam
43
There are augmented assignment operators for the +, -, *, /, and % operators, described in Table 4-1.

Equivalent assignment statement

spam += 1
spam = spam + 1

spam -= 1
spam = spam - 1

spam *= 1
*/
spam = spam * 1

spam /= 1
spam = spam / 1

spam %= 1
spam = spam % 1

The += operator can also do string and list concatenation, and the *= operator can do string and list replication. Enter the following into the interactive shell:
>>> spam = 'Hello'
>>> spam += ' world!' # concatenation the spam value + 'world!'
>>> spam
'Hello world!'

>>> bacon = ['Zophie']
>>> bacon *= 3
>>> bacon
['Zophie', 'Zophie', 'Zophie']

>>>range(4)
range(0, 4)
>>> list(range(4))
[0, 1, 2, 3]


________Methods
A method is the same thing as a function, except it is called on a value. For example, if a list value were stored in spam(variable), you would call the index() list method on that list like: spam.index('hello'). 
The method part comes after the value(value inside of the list on spam), separated by a period.

Each data type has its own set of methods. The list data type, for example, has several useful methods for finding, adding, removing, and otherwise manipulating values in a list.

Methods belong to a single data type. The append() and insert() methods are list methods and can be called only on list values, not on other values such as strings or integers.

- Methods are functions that are called on values.
- The index() list method returns the index of an item in the list.
- The append() list method adds a value to the end of a list.
- The insert() list method adds a value anywhere inside a list.
- The remove() list method removes an item, specified by the value, from a list.
- The sort() list method sorts the items in a list.
- The sort() method's reverse=True keyword argument can sort in reverse order.
- These list methods operate on the list "in place", rather than returning a new list value.

- Finding a value in a list with the index() Method
List values have an index() method that can be passed a value, and if that value exists in the list, the index of the value is returned. If the value isn’t in the list, then Python produces a ValueError error. Enter the following into the interactive shell:

>>> spam = ['hello', 'hi', 'howdy', 'heyas']
>>> spam.index('hello')
0
>>> spam.index('heyas')
3
>>> spam.index('howdy howdy howdy')
Traceback (most recent call last):
  File "<pyshell#31>", line 1, in <module>
    spam.index('howdy howdy howdy')
ValueError: 'howdy howdy howdy' is not in list

When there are duplicates of the value in the list, the index of its first appearance is returned. Enter the following into the interactive shell, and notice that index() returns 1, not 3:

>>> spam = ['Zophie', 'Pooka', 'Fat-tail', 'Pooka']
>>> spam.index('Pooka')
1

- Adding Values to Lists with the append() and insert() Methods
To add new values to a list, use the append() and insert() methods. 

append() method call adds the argument to the end of the list.
>>> spam = ['cat', 'dog', 'bat']
>>> spam.append('moose')
>>> spam
['cat', 'dog', 'bat', 'moose']

insert() method can insert a value at any index in the list. The first argument to insert() is the index for the new value, and the second argument is the new value to be inserted.
>>> spam = ['cat', 'dog', 'bat']
>>> spam.insert(1, 'chicken')
>>> spam
['cat', 'chicken', 'dog', 'bat']

Notice that the code is spam.append('moose') and spam.insert(1, 'chicken'), not spam = spam.append('moose') and spam = spam.insert(1, 'chicken'). Neither append() nor insert() gives the new value of spam as its return value. (In fact, the return value of append() and insert() is None, so you definitely wouldn’t want to store this as the new variable value.) Rather, the list is modified in place.

Removing Values from Lists with remove()
remove() method is passed the value to be removed from the list it is called on. 
>>> spam = ['cat', 'bat', 'rat', 'elephant']
>>> spam.remove('bat')
>>> spam
['cat', 'rat', 'elephant']

If the value appears multiple times in the list, only the first instance of the value will be removed. Enter the following into the interactive shell:
>>> spam = ['cat', 'bat', 'rat', 'cat', 'hat', 'cat']
>>> spam.remove('cat')
>>> spam
['bat', 'rat', 'cat', 'hat', 'cat']
The del statement is good to use when you know the index of the value you want to remove from the list. The remove() method is good when you know the value you want to remove from the list.

- Sorting the Values in a List with the sort() Method
Lists of number values or lists of strings can be sorted with the sort() method.
>>> spam = [2, 5, 3.14, 1, -7]
>>> spam.sort()
>>> spam
[-7, 1, 2, 3.14, 5]
>>> spam = ['ants', 'cats', 'dogs', 'badgers', 'elephants']
>>> spam.sort()
>>> spam
['ants', 'badgers', 'cats', 'dogs', 'elephants']




- Split up instructions across multiple lines using the \ line. 
You can also split up a single instruction across multiple lines using the \ line continuation character at the end. Think of \ as saying, “This instruction continues on the next line.” The indentation on the line after a \ line continuation is not significant. For example, the following is valid Python code:
print('Four score and seven ' + \
      'years ago...')
	  
	  
______.format() and f-strings 
- .format() method 
A good way to format objects into your string for print statements is with the string .format() method. The syntax is: 'String here{} then also {}'.format('something1', 'something2')
Ex:
print('This is a string{}'.format('INSERTED')) # just insert the word 'INSERTED' inside the {}.

print('The {2} {1} {0}'.format('fox', 'brown', 'quick')) # using index position, you can allocate and change the order of the words the way you want. 

print('The {b} {f} {q}'.format(f='fox', b='brown', q='quick')) # using these keywords as variable names you insert the order you want into {}.

Ex:
>>> print('Testing format {1} {0}'.format('vasco', 'brazil'))
Testing format brazil vasco

- f-string interpellation
name = "Jose"
age = 3
print(f'Hello, his name is {name}')

print(f'{name} is {age} years old')


	 
________List-Like Types: Strings and Tuples
Lists aren’t the only data types that represent ordered sequences of values. For example, strings and lists are actually similar, if you consider a string to be a “list” of single text characters. 
>>> name[0:4]
'Zoph'
>>> 'Zo' in name
True
>>> 'z' in name
False
>>> 'p' not in name
False
>>> for i in name:
        print('* * * ' + i + ' * * *')

* * * Z * * *
* * * o * * *
* * * p * * *
* * * h * * *
* * * i * * *
* * * e * * *

- Mutable and Immutable Data Types
But lists and strings are different in an important way. A list value is a mutable data type: It can have values added, removed, or changed. However, a string is immutable: It cannot be changed. Trying to reassign a single character in a string results in a TypeError error, as you can see by entering the following into the interactive shell:


>>> name = 'Zophie a cat'
>>> name[7] = 'the'
Traceback (most recent call last):
  File "<pyshell#50>", line 1, in <module>
    name[7] = 'the'
TypeError: 'str' object does not support item assignment

The proper way to “mutate” a string is to use slicing and concatenation to build a new string by copying from parts of the old string. Enter the following into the interactive shell:


>>> name = 'Zophie a cat'
>>> newName = name[0:7] + 'the' + name[8:12]
>>> name
'Zophie a cat'
>>> newName
'Zophie the cat'

Although a list value is mutable, the second line in the following code does not modify the list eggs:


>>> eggs = [1, 2, 3]
>>> eggs = [4, 5, 6]
>>> eggs
[4, 5, 6]
The list value in eggs isn’t being changed here; rather, an entirely new and different list value ([4, 5, 6]) is overwriting the old list value ([1, 2, 3]). This is depicted in Figure 4-2.

If you wanted to actually modify the original list in eggs to contain [4, 5, 6], you would have to do something like this:

>>> eggs = [1, 2, 3]
>>> del eggs[2]
>>> del eggs[1]
>>> del eggs[0]
>>> eggs.append(4)
>>> eggs.append(5)
>>> eggs.append(6)
>>> eggs
[4, 5, 6]

Mutable versus immutable types may seem like a meaningless distinction, but Passing References will explain the different behavior when calling functions with mutable arguments versus immutable arguments. But first, let’s find out about the tuple data type, which is an immutable form of the list data type.

_______The Tuples Data Type (Immutable)
The tuple data type is almost identical to the list data type, except in two ways. First, tuples are typed with parentheses, (and), instead of square brackets, [and]. But the main way that tuples are different from lists is that tuples, like strings, are immutable. Tuples cannot have their values modified, appended, or removed. 

You can use tuples to convey to anyone reading your code that you don’t intend for that sequence of values to change. If you need an ordered sequence of values that never changes, use a tuple. A second benefit of using tuples instead of lists is that, because they are immutable and their contents don’t change, Python can implement some optimizations that make code using tuples slightly faster than code using lists.
	- Tuples use parenthesis: (1,2,3)
	- You can use Index and Slicing just as a list.
	- Specially used when you work with integrity and you don't want your values be changed.

>>> eggs = ('hello', 42, 0.5)
>>> eggs[0]
'hello'
>>> eggs[1:3]
(42, 0.5)
>>> len(eggs)
3

>>> eggs = ('hello', 42, 0.5)
>>> eggs[1] = 99
Traceback (most recent call last):
  File "<pyshell#5>", line 1, in <module>
    eggs[1] = 99
TypeError: 'tuple' object does not support item assignment

If you have only one value in your tuple, you can indicate this by placing a trailing comma after the value inside the parentheses. Otherwise, Python will think you’ve just typed a value inside regular parentheses. The comma is what lets Python know this is a tuple value. (Unlike some other programming languages, in Python it’s fine to have a trailing comma after the last item in a list or tuple.) Enter the following type() function calls into the interactive shell to see the distinction:

>>> type(('hello',))
<class 'tuple'>
>>> type(('hello'))
<class 'str'>

- Converting Types with the List() and Tuple() functions
Just like how str(42) will return '42', the string representation of the integer 42, the functions list() and tuple() will return list and tuple versions of the values passed to them.

>>> tuple(['cat', 'dog', 5])
('cat', 'dog', 5)
>>> list(('cat', 'dog', 5))
['cat', 'dog', 5]
>>> list('hello')
['h', 'e', 'l', 'l', 'o']

Converting a tuple to a list is handy if you need a mutable version of a tuple value.

- Tuple Methods
tuple.count()

>>t = ('a', 'a', 'c')
>>t.count('a)
>>2 # show how many times the string 'a' appears.

tuple.index()
>>t = ('a', 'b', 'c')
>>t.index('a)
>>0 # return the very first time the letter 'a' occurs. 



_____References
Explained very well in: Ned batchelder's talk, "Facts and myths about Python names and values"

When you assign a list to a variable you're actually assigning a list reference to the variable and references a value that points to some bit of data like a list. When you create a list, python created the list and it's in the computer's memory but it was signed a reference to this list to variable.

ex:
spam = [0, 1, 2, 3, 4, 5] stores a reference to a list, not the actual list.

Mutable - 
Python uses references whenever variables must store values of mutable data types, such as lists or dictionaries.

Immutable 
For values of immutable data types such as strings, integers, or tuples, Python variables will store the value itself.

Although Python variables technically contain references to list or dictionary values, people often casually say that the variable contains the list or dictionary.

Any immutable value isn't actually stored inside of a variable. 

- Passing References
References are particularly important for understanding how arguments get passed to functions. When a function is called, the values of the arguments are copied to the parameter variables. For lists (and dictionaries), this means a copy of the reference is used for the parameter. The consequence is:
def eggs(someParameter):
    someParameter.append('Hello')

spam = [1, 2, 3]
eggs(spam)
print(spam)

Notice that when eggs() is called, a return value is not used to assign a new value to spam. Instead, it modifies the list in place, directly. When run, this program produces the following output:

[1, 2, 3, 'Hello']
Even though spam and someParameter contain separate references, they both refer to the same list. This is why the append('Hello') method call inside the function affects the list even after the function call has returned.

______The copy Module's copy() and deepcopy() functions 
Although passing around references is often the handiest way to deal with lists and dictionaries, if the function modifies the list or dictionary that is passed, you may not want these changes in the original list or dictionary value. For this, Python provides a module named copy that provides both the copy() and deepcopy() functions. The first of these, copy.copy(), can be used to make a duplicate copy of a mutable value like a list or dictionary, not just a copy of a reference. Enter the following into the interactive shell:


>>> import copy
>>> spam = ['A', 'B', 'C', 'D']
>>> cheese = copy.copy(spam)
>>> cheese[1] = 42
>>> spam
['A', 'B', 'C', 'D']
>>> cheese
['A', 42, 'C', 'D']

_______Sets
Sets are unordered collections of unique elements.
>>set('Parallell)
>>{'P', 'a', 'e', 'l', 'r'}

>>mylist = [1,1,1,1,1,1,2,2,2,2,2,3,3,3,3]
>>set(mylist)
>>{1, 2, 3)

________Dictionaries and structuring Data
Like a list, a dictionary is a collection of many values. But unlike indexes for lists, indexes for dictionaries can use many different data types, not just integers. Indexes for dictionaries are called keys, and a key with its associated value is called a key-value pair.
In code, a dictionary is typed with braces, {}. {'key1':'value1', 'key2', 'value2'}
	- The keys should all be strings
	- Dictionaries are unordered mappings for storing objects. 
	- The key-value pair allows users to quickly grab objects without needing to know an index location.


>>> myCat = {'size': 'fat', 'color': 'gray', 'disposition': 'loud'}
>>> 'My cat has ' + myCat['color'] + ' fur.'
'My cat has gray fur.'


- Add a key-value to dictionary:
d = {'k1':100, 'k2':200}
d['k3'] = 300
d = {'k1':100, 'k2':200, 'k3':300}


- Overwrite a existent key-value pair:
d = {'k1':100, 'k2':200}
d['k1'] = 'NEW VALUE'
d = {'k1':'NEW VALUE', 'k2':200}

- d.keys()
dict_keys(['k1', 'k2', 'k3'])

- d.values()
dict_values([100, 200, 300]

- d.items()
dict_items([('k1', 100), ('k2', 200), ('k3', 300)] # In parentheses are tuples. 

Dictionaries vs Lists
Unlike lists, items in dictionaries are unordered. The first item in a list named spam would be spam[0]. But there is no "first" item in a dictionary. While the order of items matter for determining whether two lists are the same, it does not matter in what order the key-values pair are typed in a dictionary. 

Caveats: 
	- Dictionaries can still use integer values as keys, just like lists use integers for indexes, but they do not have to start at 0 and can be any number.
	- Because dictionaries are not ordered, they can’t be sliced like lists.

>>> spam = ['cats', 'dogs', 'moose']
>>> bacon = ['dogs', 'moose', 'cats']
>>> spam == bacon
False
>>> eggs = {'name': 'Zophie', 'species': 'cat', 'age': '8'}
>>> ham = {'species': 'cat', 'age': '8', 'name': 'Zophie'}
>>> eggs == ham
True

There are Three dictionary methods that will returns lists like values of the dictionaries keys values, or both keys and values: keys(), values(), and items(). 
The values returned by these methods are not true lists: They cannot be modified and do not have an append()method. But these data types(dict_keys, dict_values, and dict_items, respectively) can be used in for loops. 

>>> spam = {'color': 'red', 'age': 42}
>>> for v in spam.values():
        print(v)
		
>>> for k in spam.keys():
        print(k)

color
age
>>> for i in spam.items():
        print(i)

('color', 'red')
('age', 42)

Using the keys(), values(), and items() methods, a for loop can iterate over the keys, values, or key-value pairs in a dictionary, respectively. Notice that the values in dict_items value returned by the item() method are tuples of the key and value. 

You can also use the multiple assignment trick in a for loop to assign the key and value to separate variables. Enter the following into the interactive shell:


>>> spam = {'color': 'red', 'age': 42}
>>> for k, v in spam.items():
        print('Key: ' + k + ' Value: ' + str(v))

Key: age Value: 42
Key: color Value: red


Recall from the previous chapter that the in and not in operators can check whether a value exists in a list. You can also use these operators to see whether a certain key or value exists in a dictionary. Enter the following into the interactive shell:


>>> spam = {'name': 'Zophie', 'age': 7}
>>> 'name' in spam.keys()
True
>>> 'Zophie' in spam.values()
True
>>> 'color' in spam.keys()
False
>>> 'color' not in spam.keys()
True
>>> 'color' in spam
False

- The GET() Method
The get() method can return a default value if a key doesn't exist.
It’s tedious to check whether a key exists in a dictionary before accessing that key’s value. Fortunately, dictionaries have a get() method that takes two arguments: the key of the value to retrieve and a fallback value to return if that key does not exist.

Enter the following into the interactive shell:


>>> picnicItems = {'apples': 5, 'cups': 2}
>>> 'I am bringing ' + str(picnicItems.get('cups', 0)) + ' cups.'
'I am bringing 2 cups.'
>>> 'I am bringing ' + str(picnicItems.get('eggs', 0)) + ' eggs.'
'I am bringing 0 eggs.'


Because there is no 'eggs' key in the picnicItems dictionary, the default value 0 is returned by the get() method. Without using get(), the code would have caused an error message, such as in the following example:

>>> picnicItems = {'apples': 5, 'cups': 2}
>>> 'I am bringing ' + str(picnicItems['eggs']) + ' eggs.'
Traceback (most recent call last):
  File "<pyshell#34>", line 1, in <module>
    'I am bringing ' + str(picnicItems['eggs']) + ' eggs.'
KeyError: 'eggs'

- The setdefault()
The setdefault() method can set a value if a key doesn't exist. The first argument passed to the method is the key to check for, and second argument is the value to set at that key if the key does not exist. If the key does exist, the setdefault() method return the key's value. 

>>> spam = {'name': 'Pooka', 'age': 5}
>>> spam.setdefault('color', 'black')
'black'
>>> spam
{'color': 'black', 'age': 5, 'name': 'Pooka'}
>>> spam.setdefault('color', 'white')
'black'
>>> spam
{'color': 'black', 'age': 5, 'name': 'Pooka'}

- Pretty Printing
If you import the pprint module into your programs, you’ll have access to the pprint() and pformat() functions that will “pretty print” a dictionary’s values. This is helpful when you want a cleaner display of the items in a dictionary than what print() provides. Modify the previous characterCount.py program and save it as prettyCharacterCount.py.

import pprint
message = 'It was a bright cold day in April, and the clocks were striking
thirteen.'
count = {}

for character in message:
    count.setdefault(character, 0)
    count[character] = count[character] + 1

pprint.pprint(count)
This time, when the program is run, the output looks much cleaner, with the keys sorted.


{' ': 13,
 ',': 1,
 '.': 1,
 'A': 1,
 'I': 1,
 'a': 4,
 'b': 1,
 'c': 3,
 'd': 3,
 'e': 5,
 'g': 2,
 'h': 3,
 'i': 6,
 'k': 2,
 'l': 3,
 'n': 4,
 'o': 2,
 'p': 1,
 'r': 5,
 's': 3,
 't': 6,
 'w': 2,
 'y': 1}
The pprint.pprint() function is especially helpful when the dictionary itself contains nested lists or dictionaries.

If you want to obtain the prettified text as a string value instead of displaying it on the screen, call pprint.pformat() instead. These two lines are equivalent to each other:


pprint.pprint(someDictionaryValue)
print(pprint.pformat(someDictionaryValue))

- Nested Dictionaries and Lists
Modeling a tic-tac-toe board was fairly simple: The board needed only a single dictionary value with nine key-value pairs. As you model more complicated things, you may find you need dictionaries and lists that contain other dictionaries and lists. Lists are useful to contain an ordered series of values, and dictionaries are useful for associating keys with values. For example, here’s a program that uses a dictionary that contains other dictionaries in order to see who is bringing what to a picnic. The totalBrought() function can read this data structure and calculate the total number of an item being brought by all the guests.


   allGuests = {'Alice': {'apples': 5, 'pretzels': 12},
                'Bob': {'ham sandwiches': 3, 'apples': 2},
                'Carol': {'cups': 3, 'apple pies': 1}}

   def totalBrought(guests, item):
       numBrought = 0
❶     for k, v in guests.items():
❷         numBrought = numBrought + v.get(item, 0)
       return numBrought

   print('Number of things being brought:')
   print(' - Apples         ' + str(totalBrought(allGuests, 'apples')))
   print(' - Cups           ' + str(totalBrought(allGuests, 'cups')))
   print(' - Cakes          ' + str(totalBrought(allGuests, 'cakes')))
   print(' - Ham Sandwiches ' + str(totalBrought(allGuests, 'ham sandwiches')))
   print(' - Apple Pies     ' + str(totalBrought(allGuests, 'apple pies')))
Inside the totalBrought() function, the for loop iterates over the key-value pairs in guests ❶. Inside the loop, the string of the guest’s name is assigned to k, and the dictionary of picnic items they’re bringing is assigned to v. If the item parameter exists as a key in this dictionary, it’s value (the quantity) is added to numBrought ❷. If it does not exist as a key, the get() method returns 0 to be added to numBrought.

The output of this program looks like this:


Number of things being brought:
- Apples 7
- Cups 3
- Cakes 0
- Ham Sandwiches 3
- Apple Pies     1

- Getting values from nested dictionaries:
ex:
d = {'k1':123,'k2':['vasco','flamengo','botafogo'], 'k3':{'insidekey':100}}
>>d['k2'][1]
>> 'flamengo'

>>d['k3']['insidekey']
>>100

e = {'alpha':['a','b','c','d','e']}
>>e['alpha'][2].upper()
>>'C'

>>> eggs = {'name': 'Zophie', 'species': 'cat'}

>>> list(eggs.keys())
['name', 'species']

>>> list(eggs.values())
['Zophie', 'cat']

>>> list(eggs.items())
[('name', 'Zophie'), ('species', 'cat')]

>>> for k, v in eggs.items():
	print(k,v)


_______Read, write in files. 
with open('file.txt', 'r') as f:
			print(f.read()) # method read, will read each line of the file.

ex2: 
with open('C:\\Users\Felipe\\Google Drive\\API\\file.txt', 'r') as file:
        for i in file:
                print(i)		

			
mode='r' is read only
mode='w' is write only (will overwrite files or create new!)
mode='a' is append only (will add on to files)
mode = 'r+' is reading and writing
mode = 'w+' is writing and reading (overwrites existing files or creates a new file!)

Other examples:
with open('file.txt', mode= 'a') as f:
        f.write('\nFOUR on fourth')

with open('file.txt', mode= 'r') as f:
        print(f.read())
		
_______Execute python commands in Windows with bat scripts.
@py C:\Users\Felipe\Scripts\windows.py %*
@pause

# %* send the arguments typed to windows.py.

----------windows.py
#! python3

import sys

print('Hello world')
print(sys.argv)

sys.argv - comand line argument are stored in a list variable.

________File Paths

- Absolute path begins with the root folder, relative paths do not.
'c:\\folder1\\folder2\\spam.png'

- Relative file path - always going to be relative to the current working directory.
'spam.png' # you doun't have to pass all the path once it will assume that you are using the current folder you were already working. you can check out it using: os.getcwd()

'folder1\\folder2\\'spam.png' # still relative path once you don't give all the path.


.folder1 - stands for this directory or this folder.
..folder1\ - means the parent folder 

'c:\\spam\\eggs.png'

>>'\\'.join(['folder1', 'folder2', 'folder3', 'file.png'])
>>'folder1\\folder2\\folder3\\file.png'

import os
os.path.join('folder1', 'folder2', 'folder3')

os.getcwd() current work directory, such as 'PWD'

os.chdir('c:\\') # change the current folder to c:\

os.makedirs('c:\\delicious\\newfolder')

os.listdir() - returns a list of strings of filenames
os.path.exists() returns True if the filename passed to it exists
os.path.isfile() and os.path.isdir() return True if they were passed a filename or file path.
os.path.getsize() returns a file's size.

_______Plaint text files 
open('c:\\user) #pythons lets you only read data from the file

helloFile = open('C:\\Users\\Felipe\\Google Drive\\API\\open.txt')
print(helloFile.read())
helloFile.close()

helloFile = open('C:\\Users\\Felipe\\Google Drive\\API\\open.txt')
lista = helloFile.readlines() # return all of the lines as string inside of a list
helloFile.close()

helloFile = open('C:\\Users\\Felipe\\Google Drive\\API\\open2.txt', 'w') # open in a write mode. Will overwrite the content of the file.
helloFile.write('Hello!!!')
helloFile.close()

helloFile = open('C:\\Users\\Felipe\\Google Drive\\API\\open.txt', 'a') # open in a write mode. Will overwrite the content of the file.
helloFile.write('\n' + 'Another line!!!123') # write the string into the file.
helloFile.close()

- Save variables into a binary file on hard disk (shelve)
With shelve module you can store things like list and dictionaries and non-text data to a binary file and then reopen. 

import shelve
shelFile = shelve.open('mydata')
#shelFile['cat'] = ['Zophie', 'Simon', 'miau'] #save a list cat in a file called mydata in the hard disk. is a binary file
print(shelFile['cat'])
shelFile.close()

shelFile.keys()
list(shelFile.keys())
['cat']

shelFile.values()
list(shelFile.values())
[['Zophie', 'Simon', 'miau']]


- Copy file, move and so on
import shutil
shutil.copy('c:\\dtest', 'c:\\') # copy file 

shutil.copytree('c:\\dtest', 'c:\\') # copy folder and your content to another place

shutil.move('c:\\', 'c:\\ ') # move or rename the file 

- Delete files 

import os
os.unlink('banco.txt') # remove file

os.rmdir() # can remove some folder you pass as argument. The folder has to be completely empty. 

import shutil
shutil.rmtree('c:\\folder1\\folder2') #remove folder and all the content. permanent delete.


import os

#os.chdir('c:\\Users\\Felipe\\')

for filename in os.listdir():
    if filename.endswith('.txt'):
        print(filename)
        #os.unlink(filename)
		
- Walk through directory 
import os 
for folderName, subfolders, filenames in os.walk('C:\\Users\\Felipe\\Google Drive'): # pass the root folder.
    #print('The folder is ' + folderName)
    #print('The subfolders  in ' + folderName + ' are: ' + str(subfolders))
    #print('The Filenames  in ' + str(subfolders) + ' are: ' + str(filenames))
    #print()
    
    for arq in filenames:
        print(arq)
		
	for file in filenames:
		if file.endswitch('.py):
			shutil.copy(os.join(folderName, file), os.join(folderName, file + '.backup')
			
- requests module
The requests module is a third-party module for downloading web pages and files. 
The request module is good for downloading files or web pages when you have the exact url you want download. But if you have to log into a website first or figuring out URL it's a complicate process. 

https://requests.readthedocs.org/en/latest

- requests.get() returns a Response object.
- The raise_for_status Response method will raise an exception if the download failed.
- You can save a downloaded file to your hard drive with calls to the iter_content() method.

1- 
import requests, os

res = requests.get('https://automatetheboringstuff.com/files/rj.txt') # download the website content.
print(res.status_code) # verify what is the status code from request.get module.
print(len(res.text))
print(res.text[:500]) # show the first 500 character from the res variable. 

2 - 
badRes = requests.get('https://automatetheboringstuff.com/asksaksak')
#print(badRes.status_code)
#print(badRes.raise_for_status()) # give you the full error. you must to treat that as try.

http://bit.ly/unipain


3 - 
res = requests.get('https://automatetheboringstuff.com/files/rj.txt')

playFile = open('RomeoAndJuliet.txt', 'wb') # open the file in bytes, unicode.
print(os.getcwd()) # returns the current work directory
for chunk in res.iter_content(10000): # open the content of variable rest and iterate in bytes.
    playFile.write(chunk) # write the content from chunk into RomeoAndJuliet.txt	

- Parsing HTML with Beautiful Soup module (Web Scraping)
Pull information from web page, known as web scraping. 

- HTML can be parsed with the BeautifulSoup module.
- BeautifulSoup is imported with the name bs4.
- Pass the string with the HTML to the bs4.BeautifulSoup() function to get a Soup object. 
- The Soup object has a select() method that can be passed a string of the CSS selector for an HTML tag.

requirement:
pip install beautifulsoup4

1 -
import bs4, requests

import bs4, requests

def getAmazonPrice(productUrl):
    res = requests.get(productUrl)
    res.raise_for_status()

    soup = bs4.BeautifulSoup(res.text, 'html.parser')
    elems = soup.select('#product-page > div > section > section.product-details.js-product-details > span.product-details-price.undefined > span > span.product-details__price--value.price-sale')
    return elems[0].text.strip() #

price = getAmazonPrice('https://www.mrporter.com/en-gb/mens/product/castaner/pablo-canvas-espadrilles/561669')
print('The price is ' + price)

_____Json
JSON is useful to know, because many websites offer JSON content as a way for programs to interact with the website. This is known as providing an application programming interface (API). Accessing an API is the same as accessing any other web page via a URL. The difference is that the data returned by an API is formatted (with JSON, for example) for machines; APIs aren’t easy for people to read.
	- Scrape raw data from websites. (Accessing APIs is often more convenient than downloading web pages and parsing HTML with Beautiful Soup.)
	-  JSON strings always use double quotes
	
- Reading JSON with the loads() Function
>>> stringOfJsonData = '{"name": "Zophie", "isCat": true, "miceCaught": 0,
"felineIQ": null}'
>>> import json
>>> jsonDataAsPythonValue = json.loads(stringOfJsonData)
>>> jsonDataAsPythonValue
{'isCat': True, 'miceCaught': 0, 'name': 'Zophie', 'felineIQ': None}

- Writing JSON with the dumps() Function
>>> pythonValue = {'isCat': True, 'miceCaught': 0, 'name': 'Zophie',
'felineIQ': None}
>>> import json
>>> stringOfJsonData = json.dumps(pythonValue)
>>> stringOfJsonData
'{"isCat": true, "felineIQ": null, "miceCaught": 0, "name": "Zophie" }'


___Setting up environment 
#pyenv install 3.7.4
#pyenv local 3.7.4

#pipenv --python 3.7.4
#pipenv install requests
#pipenv install beautifulsoup4
#pipenv install pandas

#pipenv lock -r # read the packages you have installed from pipfile.lock.

#pipenv uninstall <package> # remove the package you choose between <>.

#pipenv run python main.py


#pip3 freeze # check all the packages installed 

#pipenv shell # launch virtual environment

#pipenv --rm # remove all the environments


-----------------------------------------
GIT: 

#make main

Github:
git status

git add main.py # save a specific file
git commit -m "Adding a comment" # commit locally
git push --set-upstream origin feature/print #git push for a specific branch in github


Create branch:
git checkout -b <branch>

make clean
make setup


update with the main repository:
git checkout main

delete any config before to update the checkout main
git stash


836505057
